.. PlainTools documentation master file, created by
   sphinx-quickstart on Fri Jul 12 13:32:04 2024.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Welcome
-------

**Welcome to PlainTools's docs!**

PlainTools is a Python 3 library designed to streamline simple operations, 
loops and contexts with easy to handle classes and functions.


Documentation
-------------

The following need to be considered when reading these docs:

  - It is encouraged that you use the suggested convention:
      - import PlainTools as PT

  - It is assumed that you know the basics of Python's data types. 
      Data types such as Integers, Floats (decimal numbers), Lists, and later
      on Classes, Callables etc. are all type annotated whenever possible
      both in this documentation, in the module's docstrings, 
      and in the code itself.

      Type annotations were made in a more verbose way, with:
        - X: Integer

      Instead of:
        - x: int

      This is intended to bridge the gap between people familiar and 
      not familiar with type annotations, so notions like 'Union' are 
      substituted by the pipe '|' operator. This means that 
      'W: Integer | Float' represents a variable 'W' which is 
      *intended* to be an Integer *or* a Float number.

        Unfamiliar types like 'Number' and 'Array' can be associated with what
        meaning they first convey: a 'Number' type for example is a 
        'Integer | Float', with 'Float' itself being 'float | Decimal' 
        (only for type checking purposes, as Decimals are sparsely used here), 
        but complex numbers are left out (Gods be good) in this context 
        (and all contexts that matters for this simple module).

      Note that the Python interpreter itself will not enforce these types, 
      but here they are explicit to better illustrate what classes and functions
      expect to handle and are expected to provide in return.

  - Functionalities of the module are given in a show-first, explain-later basis.
        That means that snippets of Proto-Code and Examples will precede 
        the formal definitions of args, kwargs and results. 
        
          If the Proto-Code is too verbose, or the examples are getting in 
          your way, feel free to directly consult the module docstrings
          by the use of the provided PT.doc(\*__name__) or by reading 
          PlainTools.py directly yourself.

The code-blocks will follow the template demonstrated below;

.. py:function:: PT.foo(A, *B, C = K) -> Type:

  [Function Header]

  [Function Summary]

  :Proto-Code:
    If (Anything) is (Something):
      | (Anything) becomes (Something Else).

      Return final version of (Anything).

  :Examples:
    foo(X, Y, Z = 'W')
      | Result of this use of foo().

  :Args:
    A: Type1 | Type2[Type3]
      | Summary of arg1.

    \*B: Type1 | Type2[Type3]
      | Summary of \*arg2.

  :Kwargs: 
    C: Type1 | Type2[Type3] = K
      | Summary of kwarg1.

  :Return: 
    R: Type1 | Type2[Type3]
      | Summary of return.


Formatters
----------

**Objective**

Formatter functions are intended to take a variety of types as input and 
output data in a formatted, previsible way.


.. py:function:: PT.plist(*vals) -> List[Any]:

    Plain List.

    Transforms iterable sets into a flat list; Recursive unpacking.

    :Proto-Code:
        If one (List) contains other (Lists) inside:
            - (Unpack) the (Lists) inside, keeping only the (Values).
        
            This repeats until all (Lists) only contains plain (Values).

        Return a final (List) containing only the (Values) of everything given.

    :Examples: 
        plist((1, 2), [3, 4], {5, 6})
            | [1, 2, 3, 4, 5, 6]
            
        plist({0: '10', 1: '20', 2: '40'})
            | [0, '10', 1, '20', 2, '40']
            
        plist({'a': [1, {'b': 2}], 'c': 3})
            | ['a', 1, 'b', 2, 'c', 3]

    :Args:
        \*vals: Any | Iterable[Any]
            | Data entries to be flattened.

    :Return:
        R: List[Any]
            | Flat list containing the data entries.


.. py:function:: PT.punit(*its) -> Any | Tuple[Any]:
    
    Plain Units.

    Unpacks single units inside iterable sets;

    Returns a single value if there is only one value in the iterable.

    :Proto-Code:
        If any given (List) contains a (Single) (Value):
            - (Unpack) the (List), so it becomes it's plain (Value).

        If (Final List) contains (Multiple) (Values):
            - Return (Final List).
        
        Else, if (Final List) contains a (Single) (Value):
            - Return (Value).

    :Examples:
        punit([5], [3, 2], [[9]])
            | (5, [3, 2], 9)
        
        punit([1, 2], 3, (4,))
            | ([1, 2], 3, 4)
        
        punit([[7, 8]], {9})
            | ([7, 8], 9)

    :Args:
        \*its: Iterable[Any]
            | Iterable sets.

    :Return:
        R: Any | Tuple[Any]
            | A single item or a tuple of items.


.. py:function:: PT.pnumber(*nums) -> Number | Iterable[Number] | None:

    Plain Number.

    Numeric formatter; 
    Evaluates numeric expressions;

    Removes floating point imprecision errors with great accuracy;

    Works well expressing repeating decimals.

    :Proto-Code:
        If (Value) is (String):
            - Check if (String) of (Value) can be a (Number);
                - If (True), then (Value) becomes (Number).
                - Else, if (False), then (Value) is ignored.

        If (Value) is an (Mathematical Expression):
            - (Value) becomes the (Evaluation) of the (Mathematical Expression).
        
        If (Value) is (Float):
            - Check if (Float) can be an (Integer) without rounding;
                - If (True), then (Value) becomes an (Integer).
                - Else, if (False), then (Value) is kept as is.

            - Check if (Float) has (Repeating Decimal);
                - If (True), then (Value) becomes a (Float) (Rounded) for 3 (Repeating Decimals)
                - Else, if (False), then (Value) is not rounded.

        Return final numeric (Value).

    :Examples:
        pnumber([8.0, '0.1 * 3', '355/113'])
            | [8, 0.3, 3.1415929203539825]

        pnumber(math.e)
            | 2.718281828459045

        pnumber(1/3, 10/33, 100/333, 1000/3333)
            | [0.333, 0.30303, 0.3003003003, 0.3000300030003]

    :Args:
        \*nums: Number | Iterable[Number | String]
            | Numbers to be formatted.

    :Return:
        R: Number | Iterable[Number] | None
            | Formatted numbers, None if NaN.


.. py:function:: PT.pdecimals(*nums) -> Integer:

    Plain Decimals.

    Identifies the highest number of decimal places in a set of given numbers.

    :Proto-Code:
        Start (Decimals) as 0.

        (For Each) (Value):
            - If (String) of (Number) in (Value) have ('.') character:
                (Count) how many (Digits) there is after ('.') character.
                    - If (Digits) is greater than (Decimals):
                        (Decimals) become number of (Digits).
        
        Return final (Decimals) value.

    :Example:
        pdecimals(1.23, 4.5678, 3.1, 5.67890)
            | 4
        
        pdecimals(1/3)
            | 3

        pdecimals(math.pi)
            | 15

    :Args:
        [*]nums: Number | Iterable[Number | String]
            | Numbers to be formatted.

    :Returns:
        R: Integer
            | Highest quantity of decimal places found.


.. py:function:: PT.pstring(*objs, sep = ', ') -> String:

    Plain String.

    More comprehensible 'str()' operator; Concatenates elements of iterables.

    :Proto-Code:
        Check (Type) of (Value):
            - If (Type) is (Dictionary):
                (Include) the (Keys) and (Values) of (Dictionary) in the (String).
            - Else, if (Type) is a (List), (Tuple) or (Set):
                (Include) all (Values) in the (String).
            - Else, if (Type) is (Something Else):
                (Include) the String of (Type) in the (String).
        
        Return final version of (String).

    :Examples:
        pstring({0: 'a', 1: 'b', 2: 'c'})
            | '0 : a, 1 : b, 2 : c'
        
        pstring([1, 2, 3], (4, 5), {6, 7})
            | '1, 2, 3, 4, 5, 6, 7'
        
        pstring('Hello', ['world', '!'], sep = ' ')
            | 'Hello world !'

    :Args:
        \*objs: Any | Iterable[Any]
            | Objects to be converted to string.
        
        sep: String = ', '
            | Separator between elements in the final string.

    :Return:
        R: String
            | Single string containing the concatenated elements.    


.. py:function:: PT.pytpe(obj, *types) -> Bool | Tuple[Bool]:
    
    Plain Type Check.

    Checks if the object is an instance of the provided types.

    :Proto-Code:
        Check (Type) of (Value) and (Type) of (Asked Types):
            (For Each) (Asked Type):
                - If (Type) of (Value) is the same as this (Asked Type):
                    (Include) (True) in the final (Result)
                - Else, if (Type) of (Value) is not the same as this (Asked Type):
                    (Include) (False) in the final (Result)

        Return the final (Result).

    :Examples:
        ptype('Hello', String, Iterable, Set)
            | (True, True, False)
        
        ptype([1, 2, 3], List, Tuple, Iterable)
            | (True, False, True)
        
        ptype(42.0, Number, Integer, Float)
            | (True, False, True)

    :Args:
        obj: Any
            | Object to be checked against.
        
        \*types: Type
            | Types to compare using isinstance(obj, type).

    :Return:
        R: Bool | Tuple[Bool]
            | Sequence of Booleans according to the checks.


.. py:function:: PT.prange(*args, type = 'list') -> Iterable[Number]:

    Plain Range.

    Simulates the 'range()' function from Python 2.x.

    Instead of a *range* object, returns a plain *Iterable* of specified type.

    Args functionality is the same as standard 'range()' built-in function. 

    :Proto-Code:
        (stub)

    :Example:
        prange(5)
            | [1, 2, 3, 4, 5]

        prange(5, 2.5, 0.5)
            | [5, 4.5, 4, 3.5, 3, 2.5]
        
        prange(0, 15, 4)
            | [0, 4, 8, 12]

    :Args:
        [*]args: Number
            Functionality varies according to arguments:
                - A single parameter determines the `stop`; with `start` of 1.
                - Two parameters determines `start` and `stop`; with `step` of 1.
                - Three parameters determines `start`, `stop` and `step`; returning a `list`.
                - Four parameters determines `start`, `stop`, `step` and `type`

    :Returns:
        R: Iterable[Number] = Iterable (defined in 'get') containing the range.


.. py:function:: PT.pindex(target, *its) -> Integer | None | Tuple[Integer | None]:
    
    Plain Index.

    Returns the index of the first occurrence of 'target' in 'its'.

    :Proto-Code:
        Look for (Target) in all (Iterables) provided:
            (For Each) (Iterable):
                - If (Target) is found in this (Iterable):
                    (Include) (Target)'s (Index) in the final (Result).
                - Else, if (Target) is not found in this (Iterable):
                    (Include) (None) in the final (Result).

        Return the final (Result).

    :Examples:
        pindex(True, (False, False, True))
            | 2
        
        pindex(5, range(10))
            | 5
        
        pindex(1, (False, False, True), ['a', 'b', 'c'], range(10))
            | (2, None, 1)

    :Args:
        target: Any
            | Value to search for in the provided iterables.

        \*its: Iterable[Any]
            | One or more iterables to be checked for 'target'.
        
    :Return:
        R: Integer | None | Tuple[Integer | None]
            | Index of the first 'target' occurrence into provided iterables.


**INCOMPLETE, AHEAD BE DRAGONS!**
=================================


.. py:function:: PT.pcount(*vals: Iterable[Any],count: Number = 0,) -> Integer:

    Plain Count.

    Returns the minimum, maximum, or both sizes of an iterable.

    :Example:
        minmax([5, 2, -8, '15*2']) == (-8, 30)

    :Args:
        [*]vals: Number | Iterable[Number] = Objects to be counted.

        count: Number = (0) Condition for returning Min, Max, or both.

    :Returns:
        R: Number = Min | Max of counted elements.


.. py:function:: PT.pimport(libs: String,funs: String = None) -> Module | Object | Tuple[Module | Object]:

    Plain Import.

    Helper function for local scope importation.

    :Example:
        calc = pimport('math')
            - Allocates 'calc' as alias to 'math' module.

        pi, log = pimport('math','pi, log')
            - Allocates to variables the imported objs (math.pi & math.log).

    :Args:
        libs: String | Tuple[String] = Modules to import; Separated by ','.

        funs: String | Tuple[String] = (None) Objects to import; Sep. by ','.

    :Returns:
        R: Module | Object | Tuple[Module | Object] = Imported objects.


Debuggers
----------
**Objective**

Debugger functions bring some utility when dealing directly with the console.
Note that most take *(*)args*, but that is intended to be used as a buffer
for arbitrary exection of code when calling them.

.. py:function:: PT.clear(*args: Any,) -> None:
    
    Clear Screen.

    Simple command to clear the console if possible; Does nothing otherwise.

.. py:function:: PT.debug(*args: Any,show: Bool = True,) -> String:

    Debug Traceback.

    Shows and returns the traceback, if any, and prints it to the console.


.. py:function:: PT.eof(*args: Any,) -> SystemExit:

    End of File.

    Function that logs into .log file and waits input before sys exiting.


.. py:function:: PT.deepframe(*args: Any,) -> None:

    Deep Frame.

    Prints the full depth of the current path and the frame stack.


.. py:function:: PT.print(*args, **kwargs):

    Revisioned Print.

    Same as print() except that it does NOT print Nulls and empty strings.


.. py:function:: PT.input(*args, **kwargs):

    Revisioned Input.

    Same as input() except that it automatically formats numbers (int, float).


.. py:function:: PT.skip(num: Integer = 1,msg: String = '',spr: String = '',fim: String = '\n',) -> None:

    Line Skip.

    Prints (msg) into the cnsole (num) times. Defaults to a 1 line skip.


Instantiable Classes
--------------------
**Objective**

Instantiable Classes are objects able to be imported as is, or as already instantiated aliases,
or instantiated to your own variables.

PT.TIME() is a Instantiable Class; PT.Time() is one of its provided instances, but you can also 
'import PlainTools as PT' and instantiate 'T = PT.TIME()' to make 'T' a functional instance of the 
PT.TIME() Class, ready to be called by itself or with its methods, ie: T.lap.

.. py:class:: PT.TIME(add: Float = 0.0, std: String = 'now',) -> Class:

    Execution Timer.

    A running timer that starts immediately when instantiated.

    :Example:
        X = TIME() # Starts 'X' as a timer.

        with X: # Starts a timed context with 'X'; prints time on exit.

        X.show # Prints the current time in string format.

    :Args:
        add: Float = (*0.0*) Time to add to the timer.

        std: String = (*''*) Initial standard mode ('now', 'lap', or 'epoch').

    :Methods:
        :classmethod: mode(std: String = '') -> Class: Changes the standard mode of the timer.

        :property: now: Float = Returns the time since the last call.

        :property: lap: Float = Returns the current time.

        :property: reset: Class = Resets the timer.

        :property: string: String = Returns the time as a string.

        :property: show: String = Prints the current time in string format.

        :property: epoch: Array[Float] = Returns recorded times.

    :Returns:
        R: Float | Array[Float] = Time in seconds.milliseconds (e.g., 1.234s).

**Provided Instances - TIME()**

.. py:data:: PT.Time = TIME(std='now')
.. py:data:: PT.Runtime = TIME(std='now')
.. py:data:: PT.Crono = TIME(std='now')
